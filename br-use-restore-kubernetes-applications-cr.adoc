---
sidebar: sidebar 
permalink: br-use-restore-kubernetes-applications-cr.html 
keywords: backing up, restoring, back up, backup, restore, cloud volumes ontap, aws, azure, s3, blob, google cloud, storagegrid, back up volumes, cloud backup, restore volumes, cost, on-premises ontap, onprem, applications, virtual machines, backup and recovery 
summary: NetApp Backup and Recovery vous permet de restaurer les applications que vous avez protégées avec une politique de protection. 
---
= Restaurez des applications Kubernetes à l'aide d'une ressource personnalisée
:hardbreaks:
:allow-uri-read: 
:nofooter: 
:icons: font
:linkattrs: 
:imagesdir: ./media/


[role="lead"]
Vous pouvez utiliser des ressources personnalisées pour restaurer vos applications à partir d'un instantané ou d'une sauvegarde. La restauration à partir d'un instantané existant sera plus rapide lors de la restauration de l'application sur le même cluster.

[NOTE]
====
* Lors de la restauration d'une application, tous les points d'exécution configurés pour l'application sont restaurés avec l'application. Si un point d'exécution post-restauration est présent, il s'exécute automatiquement dans le cadre de l'opération de restauration.
* La restauration à partir d'une sauvegarde vers un espace de noms différent ou vers l'espace de noms d'origine est prise en charge pour les volumes qtree. Cependant, la restauration à partir d'un instantané vers un espace de noms différent ou vers l'espace de noms d'origine n'est pas prise en charge pour les volumes qtree.
* Vous pouvez utiliser les paramètres avancés pour personnaliser les opérations de restauration. Pour en savoir plus, consultez link:br-use-kubernetes-advanced-restore-settings.html["Utilisez les paramètres avancés de restauration des ressources personnalisées"].


====


== Restaurer une sauvegarde dans un espace de noms différent

Lorsque vous restaurez une sauvegarde dans un espace de noms différent à l'aide d'un BackupRestore CR, Backup and Recovery restaure l'application dans un nouvel espace de noms et crée un CR d'application pour l'application restaurée. Pour protéger l'application restaurée, créez des sauvegardes ou des instantanés à la demande, ou établissez une planification de protection.

[NOTE]
====
* La restauration d'une sauvegarde dans un espace de noms différent contenant des ressources existantes ne modifiera pas les ressources portant le même nom que celles de la sauvegarde. Pour restaurer toutes les ressources de la sauvegarde, supprimez et recréez l'espace de noms cible ou restaurez la sauvegarde dans un nouvel espace de noms.
* Lors de l'utilisation d'une CR pour restaurer dans un nouvel espace de noms, vous devez créer manuellement l'espace de noms de destination avant d'appliquer la CR. NetApp Backup and Recovery crée automatiquement les espaces de noms uniquement lors de l'utilisation de la CLI.


====
.Avant de commencer
Assurez-vous que la durée de validité du jeton de session AWS est suffisante pour toute opération de restauration s3 de longue durée. Si le jeton expire pendant l'opération de restauration, l'opération peut échouer.

* Consultez la  https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html["Documentation de l'API AWS"^] pour plus d'informations sur la vérification de l'expiration du jeton de session actuel.
* Consultez la  https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html["Documentation AWS IAM"^] pour plus d'informations sur les identifiants relatifs aux ressources AWS.



NOTE: Lorsque vous restaurez des sauvegardes en utilisant Kopia comme outil de déplacement de données, vous pouvez éventuellement spécifier des annotations dans le CR pour contrôler le comportement du stockage temporaire utilisé par Kopia. Consultez la  https://kopia.io/docs/getting-started/["Documentation Kopia"^] pour plus d'informations sur les options que vous pouvez configurer.

.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-backup-restore-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_Obligatoire_) Le nom de cette ressource personnalisée; choisissez un nom unique et pertinent pour votre environnement.
** *spec.appArchivePath* : Le chemin à l'intérieur de AppVault où le contenu de la sauvegarde est stocké. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get backups <BACKUP_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
** *spec.appVaultRef* : (_Obligatoire_) Le nom du AppVault où les contenus de sauvegarde sont stockés.
** *spec.namespaceMapping* : La correspondance de l’espace de noms source de l’opération de restauration avec l’espace de noms de destination. Remplacez  `my-source-namespace` et  `my-destination-namespace` par les informations de votre environnement.
+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: BackupRestore
metadata:
  name: my-cr-name
  namespace: my-destination-namespace
spec:
  appArchivePath: my-backup-path
  appVaultRef: appvault-name
  namespaceMapping: [{"source": "my-source-namespace", "destination": "my-destination-namespace"}]
----


. (_Facultatif_) Si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+

NOTE: Trident Protect sélectionne automatiquement certaines ressources en fonction de leur relation avec les ressources que vous sélectionnez. Par exemple, si vous sélectionnez une ressource de type revendication de volume persistant et qu'elle possède un pod associé, Trident Protect restaurera également le pod associé.

+
** *resourceFilter.resourceSelectionCriteria* : (Obligatoire pour le filtrage) Utilisez  `Include` ou  `Exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *resourceFilter.resourceMatchers* : Un tableau d’objets resourceMatcher. Si vous définissez plusieurs éléments dans ce tableau, ils correspondent selon une opération OU, et les champs à l’intérieur de chaque élément (group, kind, version) correspondent selon une opération ET.
+
**** *resourceMatchers[].group*: (_Optionnel_) Groupe de la ressource à filtrer.
**** *resourceMatchers[].kind*: (_Optionnel_) Type de ressource à filtrer.
**** *resourceMatchers[].version*: (_Optionnel_) Version de la ressource à filtrer.
**** *resourceMatchers[].names*: (_Optionnel_) Noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *resourceMatchers[].namespaces*: (_Optionnel_) Espaces de noms dans le champ metadata.name de Kubernetes de la ressource à filtrer.
**** *resourceMatchers[].labelSelectors* : (_Optionnel_) Chaîne de sélection d'étiquette dans le champ metadata.name de la ressource Kubernetes tel que défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "Include"
    resourceMatchers:
      - group: my-resource-group-1
        kind: my-resource-kind-1
        version: my-resource-version-1
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
      - group: my-resource-group-2
        kind: my-resource-kind-2
        version: my-resource-version-2
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
----






. Après avoir rempli le fichier  `trident-protect-backup-restore-cr.yaml` avec les valeurs correctes, appliquez le CR :
+
[source, console]
----
kubectl apply -f trident-protect-backup-restore-cr.yaml
----




== Restaurer une sauvegarde dans l'espace de noms d'origine

Vous pouvez restaurer une sauvegarde dans l'espace de noms d'origine à tout moment.

.Avant de commencer
Assurez-vous que la durée de validité du jeton de session AWS est suffisante pour toute opération de restauration s3 de longue durée. Si le jeton expire pendant l'opération de restauration, l'opération peut échouer.

* Consultez la  https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html["Documentation de l'API AWS"^] pour plus d'informations sur la vérification de l'expiration du jeton de session actuel.
* Consultez la  https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html["Documentation AWS IAM"^] pour plus d'informations sur les identifiants relatifs aux ressources AWS.



NOTE: Lorsque vous restaurez des sauvegardes en utilisant Kopia comme outil de déplacement de données, vous pouvez éventuellement spécifier des annotations dans le CR pour contrôler le comportement du stockage temporaire utilisé par Kopia. Consultez la  https://kopia.io/docs/getting-started/["Documentation Kopia"^] pour plus d'informations sur les options que vous pouvez configurer.

.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-backup-ipr-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_Obligatoire_) Le nom de cette ressource personnalisée; choisissez un nom unique et pertinent pour votre environnement.
** *spec.appArchivePath* : Le chemin à l'intérieur de AppVault où le contenu de la sauvegarde est stocké. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get backups <BACKUP_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
** *spec.appVaultRef* : (_Obligatoire_) Le nom du AppVault où les contenus de sauvegarde sont stockés.
+
Par exemple :

+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: BackupInplaceRestore
metadata:
  name: my-cr-name
  namespace: my-app-namespace
spec:
  appArchivePath: my-backup-path
  appVaultRef: appvault-name
----


. (_Facultatif_) Si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+

NOTE: Trident Protect sélectionne automatiquement certaines ressources en fonction de leur relation avec les ressources que vous sélectionnez. Par exemple, si vous sélectionnez une ressource de type revendication de volume persistant et qu'elle possède un pod associé, Trident Protect restaurera également le pod associé.

+
** *resourceFilter.resourceSelectionCriteria* : (Obligatoire pour le filtrage) Utilisez  `Include` ou  `Exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *resourceFilter.resourceMatchers* : Un tableau d’objets resourceMatcher. Si vous définissez plusieurs éléments dans ce tableau, ils correspondent selon une opération OU, et les champs à l’intérieur de chaque élément (group, kind, version) correspondent selon une opération ET.
+
**** *resourceMatchers[].group*: (_Optionnel_) Groupe de la ressource à filtrer.
**** *resourceMatchers[].kind*: (_Optionnel_) Type de ressource à filtrer.
**** *resourceMatchers[].version*: (_Optionnel_) Version de la ressource à filtrer.
**** *resourceMatchers[].names*: (_Optionnel_) Noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *resourceMatchers[].namespaces*: (_Optionnel_) Espaces de noms dans le champ metadata.name de Kubernetes de la ressource à filtrer.
**** *resourceMatchers[].labelSelectors* : (_Optionnel_) Chaîne de sélection d'étiquette dans le champ metadata.name de la ressource Kubernetes tel que défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "Include"
    resourceMatchers:
      - group: my-resource-group-1
        kind: my-resource-kind-1
        version: my-resource-version-1
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
      - group: my-resource-group-2
        kind: my-resource-kind-2
        version: my-resource-version-2
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
----






. Après avoir rempli le fichier  `trident-protect-backup-ipr-cr.yaml` avec les valeurs correctes, appliquez le CR :
+
[source, console]
----
kubectl apply -f trident-protect-backup-ipr-cr.yaml
----




== Restaurer une sauvegarde sur un cluster différent

Vous pouvez restaurer une sauvegarde sur un cluster différent en cas de problème avec le cluster d'origine.

[NOTE]
====
* Lorsque vous restaurez des sauvegardes en utilisant Kopia comme outil de déplacement de données, vous pouvez éventuellement spécifier des annotations dans le CR pour contrôler le comportement du stockage temporaire utilisé par Kopia. Consultez la  https://kopia.io/docs/getting-started/["Documentation Kopia"^] pour plus d'informations sur les options que vous pouvez configurer.
* Lorsque vous utilisez un CR pour restaurer dans un nouvel espace de noms, vous devez créer manuellement l'espace de noms de destination avant d'appliquer le CR.


====
.Avant de commencer
Assurez-vous que les conditions préalables suivantes sont remplies :

* Le cluster de destination a Trident Protect installé.
* Le cluster de destination a accès au chemin du compartiment du même AppVault que le cluster source, où la sauvegarde est stockée.
* Assurez-vous que la durée de validité du jeton de session AWS soit suffisante pour toute opération de restauration de longue durée. Si le jeton expire pendant l'opération de restauration, l'opération peut échouer.
+
** Consultez la  https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html["Documentation de l'API AWS"^] pour plus d'informations sur la vérification de l'expiration du jeton de session actuel.
** Consultez la  https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html["Documentation AWS"^] pour plus d'informations sur les identifiants relatifs aux ressources AWS.




.Étapes
. Vérifiez la disponibilité de la AppVault CR sur le cluster de destination à l'aide du plugin CLI Trident Protect :
+
[source, console]
----
tridentctl-protect get appvault --context <destination_cluster_name>
----
+

NOTE: Assurez-vous que l'espace de noms destiné à la restauration de l'application existe sur le cluster de destination.

. Consultez le contenu de la sauvegarde disponible de AppVault depuis le cluster de destination :
+
[source, console]
----
tridentctl-protect get appvaultcontent <appvault_name> \
--show-resources backup \
--show-paths \
--context <destination_cluster_name>
----
+
L'exécution de cette commande affiche les sauvegardes disponibles dans le AppVault, y compris leurs clusters d'origine, les noms des applications correspondantes, les horodatages et les chemins d'accès aux archives.

+
*Exemple de sortie :*

+
[listing]
----
+-------------+-----------+--------+-----------------+--------------------------+-------------+
|   CLUSTER   |    APP    |  TYPE  |      NAME       |        TIMESTAMP         |    PATH     |
+-------------+-----------+--------+-----------------+--------------------------+-------------+
| production1 | wordpress | backup | wordpress-bkup-1| 2024-10-30 08:37:40 (UTC)| backuppath1 |
| production1 | wordpress | backup | wordpress-bkup-2| 2024-10-30 08:37:40 (UTC)| backuppath2 |
+-------------+-----------+--------+-----------------+--------------------------+-------------+
----
. Restaurez l'application sur le cluster de destination en utilisant le nom AppVault et le chemin d'accès à l'archive :


. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-backup-restore-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_Obligatoire_) Le nom de cette ressource personnalisée; choisissez un nom unique et pertinent pour votre environnement.
** *spec.appVaultRef* : (_Obligatoire_) Le nom du AppVault où les contenus de sauvegarde sont stockés.
** *spec.appArchivePath* : Le chemin à l'intérieur de AppVault où le contenu de la sauvegarde est stocké. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get backups <BACKUP_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
+

NOTE: Si le BackupRestore CR n'est pas disponible, vous pouvez utiliser la commande mentionnée à l'étape 2 pour afficher le contenu de la sauvegarde.

** *spec.namespaceMapping* : La correspondance de l’espace de noms source de l’opération de restauration avec l’espace de noms de destination. Remplacez  `my-source-namespace` et  `my-destination-namespace` par les informations de votre environnement.
+
Par exemple :

+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: BackupRestore
metadata:
  name: my-cr-name
  namespace: my-destination-namespace
spec:
  appVaultRef: appvault-name
  appArchivePath: my-backup-path
  namespaceMapping: [{"source": "my-source-namespace", "destination": "my-destination-namespace"}]
----


. Après avoir rempli le fichier  `trident-protect-backup-restore-cr.yaml` avec les valeurs correctes, appliquez le CR :
+
[source, console]
----
kubectl apply -f trident-protect-backup-restore-cr.yaml
----




== Restaurer un instantané dans un espace de noms différent

Vous pouvez restaurer des données à partir d'un instantané à l'aide d'un fichier de ressource personnalisé (CR) soit vers un autre espace de noms, soit vers l'espace de noms source d'origine. Lorsque vous restaurez un instantané vers un autre espace de noms à l'aide d'un SnapshotRestore CR, Backup and Recovery restaure l'application dans un nouvel espace de noms et crée un CR d'application pour l'application restaurée. Pour protéger l'application restaurée, créez des sauvegardes ou des instantanés à la demande, ou définissez une planification de protection.

[NOTE]
====
* SnapshotRestore prend en charge l' `spec.storageClassMapping`attribut, mais uniquement lorsque les classes de stockage source et de destination utilisent le même système de stockage. Si vous tentez de restaurer vers une classe de stockage `StorageClass` qui utilise un système de stockage différent, l'opération de restauration échouera.
* Lorsque vous utilisez un CR pour restaurer dans un nouvel espace de noms, vous devez créer manuellement l'espace de noms de destination avant d'appliquer le CR.


====
.Avant de commencer
Assurez-vous que la durée de validité du jeton de session AWS est suffisante pour toute opération de restauration s3 de longue durée. Si le jeton expire pendant l'opération de restauration, l'opération peut échouer.

* Consultez la  https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html["Documentation de l'API AWS"^] pour plus d'informations sur la vérification de l'expiration du jeton de session actuel.
* Consultez la  https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html["Documentation AWS IAM"^] pour plus d'informations sur les identifiants relatifs aux ressources AWS.


.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-snapshot-restore-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_Obligatoire_) Le nom de cette ressource personnalisée; choisissez un nom unique et pertinent pour votre environnement.
** *spec.appVaultRef* : (_Obligatoire_) Le nom du AppVault où le contenu de l’instantané est stocké.
** *spec.appArchivePath* : Le chemin à l'intérieur de AppVault où les contenus de l’instantané sont stockés. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get snapshots <SNAPHOT_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
** *spec.namespaceMapping* : La correspondance de l’espace de noms source de l’opération de restauration avec l’espace de noms de destination. Remplacez  `my-source-namespace` et  `my-destination-namespace` par les informations de votre environnement.
+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotRestore
metadata:
  name: my-cr-name
  namespace: my-app-namespace
spec:
  appVaultRef: appvault-name
  appArchivePath: my-snapshot-path
  namespaceMapping: [{"source": "my-source-namespace", "destination": "my-destination-namespace"}]
----


. (_Facultatif_) Si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+

NOTE: Trident Protect sélectionne automatiquement certaines ressources en fonction de leur relation avec les ressources que vous sélectionnez. Par exemple, si vous sélectionnez une ressource de type revendication de volume persistant et qu'elle possède un pod associé, Trident Protect restaurera également le pod associé.

+
** *resourceFilter.resourceSelectionCriteria* : (Obligatoire pour le filtrage) Utilisez  `Include` ou  `Exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *resourceFilter.resourceMatchers* : Un tableau d’objets resourceMatcher. Si vous définissez plusieurs éléments dans ce tableau, ils correspondent selon une opération OU, et les champs à l’intérieur de chaque élément (group, kind, version) correspondent selon une opération ET.
+
**** *resourceMatchers[].group*: (_Optionnel_) Groupe de la ressource à filtrer.
**** *resourceMatchers[].kind*: (_Optionnel_) Type de ressource à filtrer.
**** *resourceMatchers[].version*: (_Optionnel_) Version de la ressource à filtrer.
**** *resourceMatchers[].names*: (_Optionnel_) Noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *resourceMatchers[].namespaces*: (_Optionnel_) Espaces de noms dans le champ metadata.name de Kubernetes de la ressource à filtrer.
**** *resourceMatchers[].labelSelectors* : (_Optionnel_) Chaîne de sélection d'étiquette dans le champ metadata.name de la ressource Kubernetes tel que défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "Include"
    resourceMatchers:
      - group: my-resource-group-1
        kind: my-resource-kind-1
        version: my-resource-version-1
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
      - group: my-resource-group-2
        kind: my-resource-kind-2
        version: my-resource-version-2
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
----






. Après avoir rempli le fichier  `trident-protect-snapshot-restore-cr.yaml` avec les valeurs correctes, appliquez le CR :
+
[source, console]
----
kubectl apply -f trident-protect-snapshot-restore-cr.yaml
----




== Restaurez un instantané dans l'espace de noms d'origine

Vous pouvez restaurer un instantané dans l'espace de noms d'origine à tout moment.

.Avant de commencer
Assurez-vous que la durée de validité du jeton de session AWS est suffisante pour toute opération de restauration s3 de longue durée. Si le jeton expire pendant l'opération de restauration, l'opération peut échouer.

* Consultez la  https://docs.aws.amazon.com/STS/latest/APIReference/API_GetSessionToken.html["Documentation de l'API AWS"^] pour plus d'informations sur la vérification de l'expiration du jeton de session actuel.
* Consultez la  https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html["Documentation AWS IAM"^] pour plus d'informations sur les identifiants relatifs aux ressources AWS.


.Étapes
. Créez le fichier de ressource personnalisée (CR) et nommez-le `trident-protect-snapshot-ipr-cr.yaml`.
. Dans le fichier que vous avez créé, configurez les attributs suivants :
+
** *metadata.name*: (_Obligatoire_) Le nom de cette ressource personnalisée; choisissez un nom unique et pertinent pour votre environnement.
** *spec.appVaultRef* : (_Obligatoire_) Le nom du AppVault où le contenu de l’instantané est stocké.
** *spec.appArchivePath* : Le chemin à l'intérieur de AppVault où les contenus de l’instantané sont stockés. Vous pouvez utiliser la commande suivante pour trouver ce chemin :
+
[source, console]
----
kubectl get snapshots <SNAPSHOT_NAME> -n my-app-namespace -o jsonpath='{.status.appArchivePath}'
----
+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: SnapshotInplaceRestore
metadata:
  name: my-cr-name
  namespace: my-app-namespace
spec:
  appVaultRef: appvault-name
  appArchivePath: my-snapshot-path
----


. (_Facultatif_) Si vous devez sélectionner uniquement certaines ressources de l'application à restaurer, ajoutez un filtrage qui inclut ou exclut les ressources marquées avec des étiquettes particulières :
+

NOTE: Trident Protect sélectionne automatiquement certaines ressources en fonction de leur relation avec les ressources que vous sélectionnez. Par exemple, si vous sélectionnez une ressource de type revendication de volume persistant et qu'elle possède un pod associé, Trident Protect restaurera également le pod associé.

+
** *resourceFilter.resourceSelectionCriteria* : (Obligatoire pour le filtrage) Utilisez  `Include` ou  `Exclude` pour inclure ou exclure une ressource définie dans resourceMatchers. Ajoutez les paramètres resourceMatchers suivants pour définir les ressources à inclure ou à exclure :
+
*** *resourceFilter.resourceMatchers* : Un tableau d’objets resourceMatcher. Si vous définissez plusieurs éléments dans ce tableau, ils correspondent selon une opération OU, et les champs à l’intérieur de chaque élément (group, kind, version) correspondent selon une opération ET.
+
**** *resourceMatchers[].group*: (_Optionnel_) Groupe de la ressource à filtrer.
**** *resourceMatchers[].kind*: (_Optionnel_) Type de ressource à filtrer.
**** *resourceMatchers[].version*: (_Optionnel_) Version de la ressource à filtrer.
**** *resourceMatchers[].names*: (_Optionnel_) Noms dans le champ Kubernetes metadata.name de la ressource à filtrer.
**** *resourceMatchers[].namespaces*: (_Optionnel_) Espaces de noms dans le champ metadata.name de Kubernetes de la ressource à filtrer.
**** *resourceMatchers[].labelSelectors* : (_Optionnel_) Chaîne de sélection d'étiquette dans le champ metadata.name de la ressource Kubernetes tel que défini dans le https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors["Documentation Kubernetes"^]. Par exemple : `"trident.netapp.io/os=linux"`.
+
Par exemple :

+
[source, yaml]
----
spec:
  resourceFilter:
    resourceSelectionCriteria: "Include"
    resourceMatchers:
      - group: my-resource-group-1
        kind: my-resource-kind-1
        version: my-resource-version-1
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
      - group: my-resource-group-2
        kind: my-resource-kind-2
        version: my-resource-version-2
        names: ["my-resource-names"]
        namespaces: ["my-resource-namespaces"]
        labelSelectors: ["trident.netapp.io/os=linux"]
----






. Après avoir rempli le fichier  `trident-protect-snapshot-ipr-cr.yaml` avec les valeurs correctes, appliquez le CR :
+
[source, console]
----
kubectl apply -f trident-protect-snapshot-ipr-cr.yaml
----

